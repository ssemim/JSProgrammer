### 1. 자료 구조 (Data Structure)

- 자료구조는 다수의 자료를 담기 위한 구조다
- 데이터의 수가 많아질수록 효율적인 자료구조가 필요하다


-> 자료 구조의 필요성에 대하여 이해할 필요 O
# 성능 비교 : 자료구조 / 알고리즘의 성능 측정 방법에 대해 이해할 필요가 있음

 [ex] 구조 1) 삽입과 추출이 적당히 둘 다 빠른 경우 ( 삽입 O(logN) / 추출 O(logN) )
      구조 2) 삽입이 느리지만 추출이 빠른 경우 ( 삽입 O(N) / 추출 O(1) )


N은 데이터의 갯수, 수가 적은 경우 어떤 구조를 사용하든 출력에 문제가 없으나, 데이터의 개수가 많아질수록 자료 구조 선택이 중요
=> 자료구조 이해 불가시 / 불필요하게 메모리와 계산을 낭비
=================================================================================

ex - [C언어 기준]
int 형식 데이터가 100만개 => 데이터 조회가 하루에 1억번 발생하는 경우  : 원하는 데이터를 가장 빠르게 찾을 수 있는 구조는?
: 트리(tree)와 같은 자료구조 활용

================================================================================= 

자료 구조의 종류

1. 선형 구조(linear data structure)  >> 데이터가 일렬로 연속적으로(순차적으로) 연결되어 있다.

- 배열(Array)
- 연결 리스트(Linked list)
- 스택 (Stack)
- 큐 (Queue)

2. 비선형 구조(non-linear data structure) >> 하나의 데이터 뒤에 다른 데이터가 여러 개 올 수 있는 구조 (일직선 연결 X여도 된다)

- 트리(tree)
- 그래프 (graph)

===================================================================================

* 효율적인 자료 구조 설계를 위해 알고리즘 지식이 필요함 => 문제 상황에 맞는 적절한 자료구조 이용 (프로그램 작성시 자료구조, 알고리즘 모두 고려할 것)

===================================================================================

프로그램의 성능 측정 방법

- 시간 복잡도(time complexity) => 알고리즘에 사용되는 연산 횟수를 측정한다.
- 공간 복잡도(spave complexity) => 알고리즘에 사용되는 메모리의 양을 측정한다

== > 공간을 많이 사용하는 대신 시간을 단축하는 방법이 흔히 사용됨


* Big-O 표기법
-> 복잡도를 표현할 때 Big-O 표기법을 사용한다
1) 특정한 알고리즘이 얼마나 효율적인지 수치적으로 표현 할 수 있다.
2) 가장 빠르게 증가하는 항만을 고려하는 표기법이다 


> 일반적으로 연산 횟수가 10억을 넘어가면 1초 이상의 시간이 소요됨

[ex] n = 1000 이라면

O(n) = 약 1000번 연산
O(nlogn) 약 10,000번 연산
O(n^2) 약 1,000,000번 연산
O(n^3) 약 1,000,000,000 번 연산



====================================================================================

Big-O 표기법으로 시간 복잡도를 표기할 때에는 가장 큰 항만을 표시한다.

-> 가장 큰 항에 붙어있는 계수는 제거한다.

O(3n^2+n) = O(n^2) 

-> 현실 세계에서는 동작 시간이 1초 이내인 알고리즘을 설계할 필요가 있다.

====================================================================================

-> 코딩 테스트에서 메모리의 크기를 나타낼 때는 일반적으로 MB 단위로 표기한다. 

int a [1000] : 4KB
int a [1000000] : 4MB
int a [2000][2000] : 16MB

->  자료 구조의 종류로는 스택, 큐, 트리 등이 있다.
-> 프로그램을 작성할 때는 자료구조를 적절히 활용하여 시간 복잡도를 최소화하여햐 한다.

====================================================================================


# 배열(Array)와 리스트(List)

# 배열 (Array)
=> 가장 기본적인 자료구조다
=> 여러 개의 변수를 담는 공간으로 이해할 수 있다.

=> ** 배열은 인덱스(index)가 존재하며, 인덱스는 0부터 시작한다.
=> ** 특정한 인덱스에 직접적으로 접근 가능 -> 수행 시간 : O(1)

여러개의 동일한 변수가 나열되어 있거나, 어떠한 수열이나 수학에서의 벡터 등을 표현 할 때는 배열을 사용
배열은 여러 개의 변수를 담는 공간, 일반적으로 같은 성질을 가지는 변수가 연속적으로 담기는 경우가 많음

(ex - 실수 배열은 모든값이 실수, 정수 배열은 모든값이 정수 등등) => 비슷한 성질을 가진 변수가 쭉 나열한 형태로써 배열잉 표현된다


- * 배열의 특징

: 컴퓨터의 메인 메모리에서 배열의 공간은 연속적으로 할당된다.
장점 : 캐시(cache) 히트 가능성이 높으며, 조회가 빠르다.
단점 : 배열의 크기를 미리 지정해야 하는 것이 일반적이므로, 데이터의 추가 및 삭제에 한계가 있다.

- 기본적으로 동적 배열이기 때문에, 배열의 크기가 미리 정해져 있지 않다고 하더라도 배열의 크기가 꽉 찼다고 하더라도
뒤쪽에 새로운 원소를 추가하는 등의 작업이 가능합니다.


# 연결 리스트 (Linked List)

- 연결 리스트는 컴퓨터의 메인 메모리상에서 주소가 연속적이지 않다.
- 배열과 다르게 크기가 정해져 있지 않고, ** 리스트의 크기는 동적으로 변경 가능하다.

장점 : 포인터(pointer)를 통해 다음 데이터의 위치를 가리킨다는 점에서 삽입과 삭제가 간편하다.
단점 : 특정 번째의 원소를 검색할 때는 앞에서부터 원소를 찾아야 하므로, ** 데이터 검색 속도가 느리다.



======================================================================================

# 연결 리스트를 직접 구현하지 않아도 대부분의 알고리즘 문제를 해결하기에는 어려움이 없다 

-> JS에서는 배열 기능을 제공한다
 - 일반적인 프로그래밍 언어에서의 배열로 이해할 수 있다.
 - JS의 배열은 일반 배열처럼 임의의 인덱스를 이용해 직접적인 접근이 가능하다.
 - JS의 배열은 동적 배열의 기능을 제공하여, 맨 뒤의 위치에 원소 추가가 가능하다.

 ======================================================================================

 - JS의 배열 자료형은 동적 배열이다.
 - 배열의 용량이 가득 차면, 자동으로 크기를 증가시킨다.
 - 내부적으로 포인터(pointer)를 사용하여, 연결 리스트의 장점도 가지고 있다.
 - 배열(array) 혹은 스택(stack)의 기능이 필요할 때 사용할 수 있다.
 --> 큐(queue)의 기능을 제공하지 못한다. (비효율적)

=======================================================================================


JS에서는 대괄호를 이용해 간단히 배열을 생성할 수 있다.
(ex)
//빈 배열 생성

let arr = [];

arr.push(7);
arr.push(8);
arr.push(9);  // push 메소드로 배열에 집어넣음

for(let i=0; i< arr.length; i++){
console.log(arr[i])
}

================================================================================================

JS에서는 Array()를 이용해 간단히 배열을 생성할 수 있다.
(ex)
//빈 배열 생성

let arr = new Array();
arr.push(7);
arr.push(8);
arr.push(9);

for(let i =0; i<arr.length; i++){
console.log(arr[i]);

}

 > JS의 배열은 일반적인 변수 외에도 객체를 담을 수도 있다.
(ex)
 let arr = ["Hello",777,true];
 console.log(arr);

 ['Hello',777,true]

JS에서는 임의의 크기를 가지는 배열을 만들 수 있다.
원하는 값을 직접 입력하여 초기화 할 수 있다.
크기가 N인 1차원 배열을 만드는 방법은 다음과 같다

// 원하는 값을 직접 입력하여 초기화
let arr1 = [0,1,2,3,4];
console.log(arr1);

// 하나의 값으로 초기화

let arr2 = Array.from({length:5}, () => 7);
console.log(arr2);

==========================================================================================================

> 2차원 배열이 필요할 때는 다음과 같이 원하는 값을 직접 넣어 초기화 할 수 있다.
(ex)
// 원하는 값을 직접 입력하여 초기화

let arr1 = [
[0,1,2,3],
[4,5,6,7],
[8,9,10,11]
];

console.log(arr1);  

실행 결과

[
[0,1,2,3],
[4,5,6,7],
[8,9,10,11]
]

=================================================================================================================

> 크기가 N x M인 2차원 리스트(배열) 만들기

최신 JS (ES6 이상) 에서 사용가능한 문법
-> 한 줄로 2차원 배열을 초기화 할 수 있다.
-> 배열의 각 원소에 크기가 5인 배열을 할당한다 


(ex) let arr = Array.from(Array(4), () => new Array(5))

console.log(arr);

[
[<5 empty items>],
[<5 empty items>],
[<5 empty items>],
[<5 empty items>],
]

-> 다음과 같이 반복문을 이용하여 2차원 배열을 초기화 할 수 있다.

(ex)
// 반복문을 이용해 배열 초기화

let arr2 = new Array(3);
for(let i =0; i < arr2.length; i++ ){
arr2[i] = Array.from(
{ length : 4 },
(undefined,j) => i * 4 + j 
);
}
console.log(arr2);

실행 결과

[
[0,1,2,3],
[4,5,6,7],
[8,9,10,11]
]

===================================================================================================================

*** 
JS 배열은 동적 배열이다
배열이 생성된 이후에도 배열의 크기를 임의로 변경할 수 있다.
push() 메서드를 통해 배열의 가장 뒤쪽에 새로운 원소를 추가할 수 있다.

(ex)
let arr = [5,6,7,8,9];
arr.length = 8;
arr[7] = 3;
arr.push(1);

for(let x of arr){ //동적 배열 표현
console.log(x);
}


* concat() 메소드 : 여러 개의 배열을 이어 붙여서 합친 결과를 반환한다 O(N)
(ex)
let arr1 = [1,2,3,4,5];
let arr2 = [6,7,8,9,10];

let arr = arr1.concat(arr2,[11,12],[13]);

console.log(arr);

실행 결과

[
1,2,3,4,5,6,
7,8,9,10,11,12,13
]

* slice(left,right) 메소드 : 특정 구간의 원소를 꺼낸 배열을 반환한다 O(N)
(ex)
let arr = [1,2,3,4,5];
let result = arr.slice(2,4);

console.log(result);

실행 결과

[3,4]

* indexOf() 메소드 : 특정한 값을 가지는 원소의 첫째 인덱스를 반환한다 O(N)
- 만약, 해당하는 원소가 없는 경우 -1을 반환한다.

let arr = [7,3,5,6,6,2,1];

console.log(arr.indexOf(5));
console.log(arr.indexOf(6));
console.log(arr.indexOf(8));

실행 결과

2
3
-1



====================================================================================================

*** 연결 리스트(Linked List)

- 연결 리스트는 각 노드가 한 줄로 연결되어 있는 자료 구조다.
- 각 노드는 (데이터,포인터)의 형태를 가진다.
- 포인터 : 다음 노드의 메모리 주소를 가리키는 목적으로 사용된다.

* 연결성 : 각 노드의 포인터는 다음 혹은 이전 노드를 가리킨다.


==> 연결 리스트를 이용하면, 다양한 자료 구조를 구현할 수 있다.
ex) 스택, 큐 등

JS는 연결 리스트를 활용하는 자료 구조를 제공한다.
그래서 연결 리스트를 실제로 구현해야 하는 경우는 적지만, 그 원리에 대해서 이해할 필요가 있음 

-

** 연결 리스트와 배열을 비교하여 장단점 파악이 중요

> 특정 위치의 데이터를 삭제할 때, 일반 배열에서는 O(N)만큼의 시간이 소요됨
--> 연결 리스트를 사용하면 연결만 끊어주면 됨
(따라서, 삭제할 위치를 정확히 알고 있다면 O(1)의 시간이 소요) 

>> 삽입시 : 배열 > 인덱스를 밀어서 삭제 후 삽입 / 삭제시에도 마찬가지 (최악의 경우 총 N만큼의 시간 요구 )
           연결 리스트 > 새 인덱스의 포인터가 다음 인덱스의 포인터를 가리킬 수 있도록 설계하는 경우 (1만큼의 시간 소요)

==========================================================================================================

*** 스택 (Stack) 

- 먼저 들어온 데이터가 나중에 나가는 자료구조 (박스 쌓인 형태)
--> 새로운 원소를 삽입 할 때 / 삭제 할 때에는 마지막 원소가 삭제

머리(head) = 최상위 원소
==> 알고리즘 테스트에서 등장 빈도 높음

* 스택이 제공하는 연산

삽입(Push) / 시간복잡도 1 / 스택에서 원소를 삽입하는 연산
추출(Pop) / 시간복잡도 1 / 스택에서 원소를 추출하는 연산 
최상위 원소(Top) / 시간 복잡도 1 / 스텍의 최상위 원소(마지막에 들어온 원소)를 확인하는 연산
Empty / 시간 복잡도 1 / 스택이 비어있는지 확인하는 연산 


==========================================================================================================


JS에서 스택을 구현하는 방법 => 배열 자료형을 이용
JS의 배열 자료형 => push() / pop() 메서드를 제공 (왜냐면 js의 기본 배열은 동적 배열이라서) 
따라서 일반적으로 스택 구현 시, JS의 array를 사용 


[ex]

let stack = [];

// 삽입 5 - 삽입 2 - 삽입 3 - 삽입 7 - 삭제() - 삽입 1 - 삽입 4 - 삭제()

stack.push(5);
stack.push(2);
stack.push(3);
stack.push(7);
stack.pop();
stack.push(1);
stack.push(4);
stack.pop();

let reversed = stack.slice().reverse();
console.log(reversed); // 최상단 원소부터 출력   출력시 [1,3,2,5]
console.log(stack);          출력시  [5,2,3,1]

--------------------------------------------------------------------------------------------------

연결 리스트로 스택 구현 시

스택을 연결 리스트로 구현하면 삽입/삭제에 있어서 시간복잡도 1을 보장할 수 있음 
연결 리스트로 구현할 때에는 머리(head)를 가리키는 한 개의 포인터만 가진다.
머리 (head) : 남아있는 원소 중 가장 마지막에 들어온 데이터를 가리키는 포인터

삽입시 머리 위치에 데이터를 넣음
삭제시 머리 위치에서 데이터를 꺼냄 

(머리 위치 포인터의 메모리 주소만 바꿔주면 된다)

======================================================================================================

*** 큐 (Queue)

큐는 먼저 삽입된 데이터가 먼저 추출되는 자료 구조
(줄같은 존재임 / 게임 대기 큐는 먼저 대기한 사람이 먼저 게임에 입장)


==> 탐색 알고리즘에서 사용 빈도가 높음 (너비 우선 탐색, 최단경로 알고리즘 등에서 많이 사용)


* 연결 리스트로 큐 구현하기

- 큐를 연결 리스트로 구현하면, 삽입과 삭제에 있어서 시간복잡도 1 보장 가능
- 연결 리스트로 구현 할 때에는 머리(head)와 꼬리(tail) 두 개의 포인터를 가진다. 
- 머리(head) : 남아있는 원소 중 가장 먼저 들어 온 데이터를 가리키는 포인터
- 꼬리(tail) : 남아있는 원소 중 가장 마지막에 들어 온 데이터를 가리키는 포인터 

그러므로 삽입시 꼬리 위치에 데이터 넣고 삭제시 머리 위치에서 데이터를 꺼냄

-> 다수의 데이터를 삽입 및 삭제할 때에 대하여 수행 시간을 측정 할 수 있다. 
-> 단순히 배열 자료형을 이용 할 때 보다 연결 리스트를 사용 할 때 수행 시간 관점에서 효율적이다.
-> JS에서는 Dictionary 자료형을 이용하여 큐(queue)를 구현하면 간단하다.


[ex]

class Queue{ // 클래스로 정의 가능

constructor(){

this.items = {};
this.headIndex = 0;
this.tailIndex= 0; 

}

enqueue(item){ // 새 원소가 들어오는 연산
this.items[this.tailIndex] = item;
this.tailIndex++;
}

dequeue(){ // 현재 큐에서 하나의 원소를 꺼내는 연산
const item = this.items[this.headIndex];
delete this.items[this.headIndex];
this.headIndex++;
return item;
}

peek(){ // 다음으로 꺼낼 원소, 헤드 위치에 있는 원소를 부르는 연산
 return this.items[this.headIndex];
}

getlength(){ // 현재 큐에 포함되어있는 원소 갯수 반환하는 연산
return this.tailIndex - this.headIndex; 
}

}


// 구현된 큐 라이브러리 사용
queue = new Queue(); 


// 삽입 5 - 삽입 2 -삽입 3 - 삽입 7 - 삭제 - 삽입 1- 삽입 4 - 삭제

queue.enqueue(5);
queue.enqueue(2);
queue.enqueue(3);
queue.enqueue(7);
queue.dequeue();
queue.enqueue(1);
queue.enqueue(4);
queue.dequeue();

// 먼저 들어온 순서대로 출력

while(queue.getLength() !=0){
console.log(queue.dequeue());
}


실행 결과 [3,7,1,4]

===================================================================================================

** 트리(Tree)와 우선순위 큐 (Priority Queue)

> 고급 알고리즘 풀이시 우선순위 큐를 이용하는 경우가 많음(최단경로 등)
> 시간 효율적으로 동작하는 알고리즘 설계시 사용


## 트리 (Tree)

- 가계도와 같이 계층적인 구조를 표현할 때 사용할 수 있는 자료구조
- 나무의 형태를 뒤집은 것과 같이 생김, 각각의 노드는 자식 노드를 가질 수 있음

- 루트 노드 (root node) 부모가 없는 최상위 노드, 뿌리 역할 
- 단말 노드 (lead node) 자식이 없는 노드, 더 이상 아래로 내려갈 수 없는 노드

트리(tree)에서는 부모와 자식 관계가 성립한다.
형제 관계 : 같은 부모 노드를 가진 노드사이의 관계

깊이(depth) : 루트 노드에서의 길이(length)
-이 때, 길이란 출발 노드에서 목적지 노드까지 거쳐야 하는 간선의 수를 의미한다.
- 트리의 높이(height)는 루트 노드에서 가장 깊은 노드까지의 길이를 의미한다. 

이진 트리(Binary Tree)

- 이진 트리는 최대 2개의 자식을 가질 수 있는 트리를 말한다.

우선순위 큐(Priority Queue)

- 우선순위 큐는 우선순위에 따라서 데이터를 추출하는 자료구조
- 컴퓨터 운영체제, 온라인 게임 매칭 등에서 사용
- 우선순위 큐는 일반적으로 힙(heap)을 이용해 구현한다.

스택(Stack) / 가장 나중에 삽입된 데이터
큐(Queue) / 가장 먼저 삽입된 데이터
우선순위 큐(Priority queue) / 가장 우선순위가 높은 데이터


- 우선 순위 큐는 다양한 방법으로 구현할 수 있음
- 데이터의 개수가 N개일 때, 구현 방식에 따른 시간 복잡도는 다음과 같다

리스트 자료형 : 삽입시간 O(1) / 삭제시간 O(N)
힙(Heap) : 삽입시간 O(logN) / 삭제시간 O(logN)


: 일반적인 형태의 큐는 선형적인 구조를 가진다.
: 반면에 우선순위 큐는 이진 트리(binary tree) 구조를 사용하는 것이 일반적 

이진트리 -> 최대 2개까지의 자식을 가지고 있으며 비 선형적인 구조

포화 이진 트리 : 루트(리프) 노드를 제외한 모든 노드가 두 자식을 가지고 있는 트리
완전 이진 트리 : 모든 노드가  왼쪽 자식부터 채워진 트리 (루트 - 루트 왼쪽 - 루트 왼쪽의 왼쪽 순으로)

높이 균형 트리 : 왼쪽 자식 트리와 오른쪽 자식 트리의 높이가 1 이상 차이나지 않는 트리


## 힙(Heap)

힙(heap)은 원소들 중에서 최댓값 또는 최솟값을 빠르게 찾아내는 자료 구조이다.
최대 힙(max heap) : 값이 큰 원소부터 추출한다.
최소 힙(min heap) : 값이 작은 원소부터 추출한다.

힙은 원소의 삽입과 삭제를 위해 O(logN)의 수행 시간을 요구한다.
단순한 N개의 데이터를 힙에 넣었다가 모두 꺼내는 작업은 정렬과 동일하다.
이 경우 시간 복잡도는 O(NlogN)이다.


최대 힙(Max Heap) : 부모 노드의 키 값이 자식 노드의 키 값보다 값이 큰 완전 이진 트리를 의미함 
 --> 루트 노드가 가장 크며, 값이 큰 데이터가 우선 순위를 가진다.

최소 힙(Min Heap) : 부모 노드의 키 값이 자식 노드의 키 값보다 항상 작다 
 --> 루트 노드가 가장 작으며, 값이 작은 데이터가 우선 순위를 가진다.

#최소 힙 구성 함수 (Heapify)
-(상향식) 부모로 거슬러 올라가며, 부모보다 자신이 더 작은 경우에 위치를 교체한다. 
-->[삽입] 새로운 원소가 삽입되었을 때 O(logN)의 시간 복잡도로 힙 성질을 유지하도록 할 수 있다.
-->[삭제] 원소가 제거 되었을 때 O(logN)의 시간 복잡도로 힙 성질을 유지하도록 할 수 있다. 
   원소를 제거할 때에는 가장 마지막 노드가 루트 노드의 위치에 오도록 한다. 
   이후에 루트 노드에서부터 하향식으로 (더 작은 자식 노드로) heapify()를 진행한다.

힙(Heap)의 특징
- 거슬러 갈 때 마다 처리해야 하는 범위에 포함된 원소의 개수가 절반씩 줄어든다
- 따라서 삽입과 삭제에 대한 시간 복잡도는 O(logN)이다.

==> 우선순위 q의 목적으로 사용하기에 매우 적합함

JS는 기본적으로 우선순위 큐를 라이브러리로 제공하지 않는다.
최단 경로 알고리즘 등에서 힙(heap)이 필요한 경우, 별도의 라이브러리를 사용해야한다.


=================================================================================================


* 그래프(Graph) 표현


그래프(graph)란 사물을 정점(vertex 또는 node)과 간선(edge :통로)으로 나타내기 위한 도구
-> 그래프 표현 방식 두 가지

1. 인접 행렬(adjacency matrix) : 2차원 배열을 사용하는 방식 : 코딩테스트/알고리즘 구현 시 종종 사용
2. 인접 리스트(adjacency list) : 연결 리스트를 이용하는 방식 : 일반적인 그래프 문제 (최단경로 등)에 사용 


# 인접 행렬(adjacency matrix) : 그래프를 2차원 배열로 표현, 가로 세로 모두 노드 
자기 자신으로 도달하기 위한 거리는 0 / 노드 간 간선이 없는 경우, 무한으로 표현

행(세로) : 시작 노드 
열(가로) : 도착 노드

그러므로 노드 개수 x 노드 개수 만큼 공간이 필요함

* 인접 행렬 - 무방향 무가중치 그래프
-> 모든 간선이 방향성을 가지지 않는 그래프를 무방향 그래프라고 한다.
-> 모든 간선에 가중치가 없는 그래프를 무가중치 그래프라고 한다.
--> 무방향 비가중치 그래프가 주어졌을 때, 연결되어 있는 상황을 인접 행렬로 출력할 수 있다.

* 인접 행렬 - 방향 가중치 그래프
-> 모든 간선이 방향을 가지는 그래프를 방향 그래프라고 한다.
-> 모든 간선에 가중치가 있는 그래프를 가중치 그래프라고 한다.
--> 방향 가중치 그래프가 주어졌을 때, 연결되어 있는 상황을 인접 행렬로 출력할 수 있다.



# 인접 리스트 (adjacency list)에서는 그래프를 리스트로 표현한다.
(자기 자신으로 가는 것은 포함되지 않기 때문에 기입하지 않는다.) 
nxn 꼴의 공간이 필요하지 않기 때문에, 메모리 최적화에 적합함

* 인접 리스트 - 무방향 무가중치 그래프
- 모든 간선이 방향성을 가지지 않는 그래프를 무방향 그래프라고 한다.
- 모든 간선에 가중치가 없는 그래프를 무가중치 그래프라고 한다.
- 무방향 비가중치 그래프가 주어졌을 때, 연결되어 있는 상황을 인접 리스트로 출력할 수 있다. 


---------------------------------------------------------------------------------------------


그래프의 시간 복잡도

1. 인접 행렬 : 모든 정점들의 연결 여부를 저장해 O(V^2)의 공간을 요구한다.
--> 공간 효율성이 떨어지지만, 두 노드의 연결 여부를 O(1)에 확인할 수 있다.

2. 인접 리스트 : 연결된 간선의 정보만을 저장하여 O(V+E)의 공간을 요구한다.
--> 공간 효율성이 우수하지만, 두 노드의 연결 여부를 확인하기 위해 O(V)의 시간이 필요하다.


                      필요한 메모리       연결 여부 확인
인접 행렬                 O(V^2)              O(1)
인접 리스트               O(V+E)              O(V)


--------------------------------------------------------------------------------------------


인접 행렬 vs 인접 리스트 

최단 경로 알고리즘을 구현할 때, 어떤 자료구조가 유용할까
--> 각각 근처의 노드와 연결되어 있는 경우가 많으므로, 간선 개수가 적어 인접 리스트가 유리하다.























