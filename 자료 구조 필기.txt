### 1. 자료 구조 (Data Structure)

- 자료구조는 다수의 자료를 담기 위한 구조다
- 데이터의 수가 많아질수록 효율적인 자료구조가 필요하다


-> 자료 구조의 필요성에 대하여 이해할 필요 O
# 성능 비교 : 자료구조 / 알고리즘의 성능 측정 방법에 대해 이해할 필요가 있음

 [ex] 구조 1) 삽입과 추출이 적당히 둘 다 빠른 경우 ( 삽입 O(logN) / 추출 O(logN) )
      구조 2) 삽입이 느리지만 추출이 빠른 경우 ( 삽입 O(N) / 추출 O(1) )


N은 데이터의 갯수, 수가 적은 경우 어떤 구조를 사용하든 출력에 문제가 없으나, 데이터의 개수가 많아질수록 자료 구조 선택이 중요
=> 자료구조 이해 불가시 / 불필요하게 메모리와 계산을 낭비
=================================================================================

ex - [C언어 기준]
int 형식 데이터가 100만개 => 데이터 조회가 하루에 1억번 발생하는 경우  : 원하는 데이터를 가장 빠르게 찾을 수 있는 구조는?
: 트리(tree)와 같은 자료구조 활용

================================================================================= 

자료 구조의 종류

1. 선형 구조(linear data structure)  >> 데이터가 일렬로 연속적으로(순차적으로) 연결되어 있다.

- 배열(Array)
- 연결 리스트(Linked list)
- 스택 (Stack)
- 큐 (Queue)

2. 비선형 구조(non-linear data structure) >> 하나의 데이터 뒤에 다른 데이터가 여러 개 올 수 있는 구조 (일직선 연결 X여도 된다)

- 트리(tree)
- 그래프 (graph)

===================================================================================

* 효율적인 자료 구조 설계를 위해 알고리즘 지식이 필요함 => 문제 상황에 맞는 적절한 자료구조 이용 (프로그램 작성시 자료구조, 알고리즘 모두 고려할 것)

===================================================================================

프로그램의 성능 측정 방법

- 시간 복잡도(time complexity) => 알고리즘에 사용되는 연산 횟수를 측정한다.
- 공간 복잡도(spave complexity) => 알고리즘에 사용되는 메모리의 양을 측정한다

== > 공간을 많이 사용하는 대신 시간을 단축하는 방법이 흔히 사용됨


* Big-O 표기법
-> 복잡도를 표현할 때 Big-O 표기법을 사용한다
1) 특정한 알고리즘이 얼마나 효율적인지 수치적으로 표현 할 수 있다.
2) 가장 빠르게 증가하는 항만을 고려하는 표기법이다 


> 일반적으로 연산 횟수가 10억을 넘어가면 1초 이상의 시간이 소요됨

[ex] n = 1000 이라면

O(n) = 약 1000번 연산
O(nlogn) 약 10,000번 연산
O(n^2) 약 1,000,000번 연산
O(n^3) 약 1,000,000,000 번 연산



====================================================================================

Big-O 표기법으로 시간 복잡도를 표기할 때에는 가장 큰 항만을 표시한다.

-> 가장 큰 항에 붙어있는 계수는 제거한다.

O(3n^2+n) = O(n^2) 

-> 현실 세계에서는 동작 시간이 1초 이내인 알고리즘을 설계할 필요가 있다.

====================================================================================

-> 코딩 테스트에서 메모리의 크기를 나타낼 때는 일반적으로 MB 단위로 표기한다. 

int a [1000] : 4KB
int a [1000000] : 4MB
int a [2000][2000] : 16MB

->  자료 구조의 종류로는 스택, 큐, 트리 등이 있다.
-> 프로그램을 작성할 때는 자료구조를 적절히 활용하여 시간 복잡도를 최소화하여햐 한다.

====================================================================================


# 배열(Array)와 리스트(List)

# 배열 (Array)
=> 가장 기본적인 자료구조다
=> 여러 개의 변수를 담는 공간으로 이해할 수 있다.

=> ** 배열은 인덱스(index)가 존재하며, 인덱스는 0부터 시작한다.
=> ** 특정한 인덱스에 직접적으로 접근 가능 -> 수행 시간 : O(1)

여러개의 동일한 변수가 나열되어 있거나, 어떠한 수열이나 수학에서의 벡터 등을 표현 할 때는 배열을 사용
배열은 여러 개의 변수를 담는 공간, 일반적으로 같은 성질을 가지는 변수가 연속적으로 담기는 경우가 많음

(ex - 실수 배열은 모든값이 실수, 정수 배열은 모든값이 정수 등등) => 비슷한 성질을 가진 변수가 쭉 나열한 형태로써 배열잉 표현된다


- * 배열의 특징

: 컴퓨터의 메인 메모리에서 배열의 공간은 연속적으로 할당된다.
장점 : 캐시(cache) 히트 가능성이 높으며, 조회가 빠르다.
단점 : 배열의 크기를 미리 지정해야 하는 것이 일반적이므로, 데이터의 추가 및 삭제에 한계가 있다.

- 기본적으로 동적 배열이기 때문에, 배열의 크기가 미리 정해져 있지 않다고 하더라도 배열의 크기가 꽉 찼다고 하더라도
뒤쪽에 새로운 원소를 추가하는 등의 작업이 가능합니다.


# 연결 리스트 (Linked List)

- 연결 리스트는 컴퓨터의 메인 메모리상에서 주소가 연속적이지 않다.
- 배열과 다르게 크기가 정해져 있지 않고, ** 리스트의 크기는 동적으로 변경 가능하다.

장점 : 포인터(pointer)를 통해 다음 데이터의 위치를 가리킨다는 점에서 삽입과 삭제가 간편하다.
단점 : 특정 번째의 원소를 검색할 때는 앞에서부터 원소를 찾아야 하므로, ** 데이터 검색 속도가 느리다.



======================================================================================

# 연결 리스트를 직접 구현하지 않아도 대부분의 알고리즘 문제를 해결하기에는 어려움이 없다 

-> JS에서는 배열 기능을 제공한다
 - 일반적인 프로그래밍 언어에서의 배열로 이해할 수 있다.
 - JS의 배열은 일반 배열처럼 임의의 인덱스를 이용해 직접적인 접근이 가능하다.
 - JS의 배열은 동적 배열의 기능을 제공하여, 맨 뒤의 위치에 원소 추가가 가능하다.

 ======================================================================================

 - JS의 배열 자료형은 동적 배열이다.
 - 배열의 용량이 가득 차면, 자동으로 크기를 증가시킨다.
 - 내부적으로 포인터(pointer)를 사용하여, 연결 리스트의 장점도 가지고 있다.
 - 배열(array) 혹은 스택(stack)의 기능이 필요할 때 사용할 수 있다.
 --> 큐(queue)의 기능을 제공하지 못한다. (비효율적)

=======================================================================================


JS에서는 대괄호를 이용해 간단히 배열을 생성할 수 있다.
(ex)
//빈 배열 생성

let arr = [];

arr.push(7);
arr.push(8);
arr.push(9);  // push 메소드로 배열에 집어넣음

for(let i=0; i< arr.length; i++){
console.log(arr[i])
}

================================================================================================

JS에서는 Array()를 이용해 간단히 배열을 생성할 수 있다.
(ex)
//빈 배열 생성

let arr = new Array();
arr.push(7);
arr.push(8);
arr.push(9);

for(let i =0; i<arr.length; i++){
console.log(arr[i]);

}

 > JS의 배열은 일반적인 변수 외에도 객체를 담을 수도 있다.
(ex)
 let arr = ["Hello",777,true];
 console.log(arr);

 ['Hello',777,true]

JS에서는 임의의 크기를 가지는 배열을 만들 수 있다.
원하는 값을 직접 입력하여 초기화 할 수 있다.
크기가 N인 1차원 배열을 만드는 방법은 다음과 같다

// 원하는 값을 직접 입력하여 초기화
let arr1 = [0,1,2,3,4];
console.log(arr1);

// 하나의 값으로 초기화

let arr2 = Array.from({length:5}, () => 7);
console.log(arr2);

==========================================================================================================

> 2차원 배열이 필요할 때는 다음과 같이 원하는 값을 직접 넣어 초기화 할 수 있다.
(ex)
// 원하는 값을 직접 입력하여 초기화

let arr1 = [
[0,1,2,3],
[4,5,6,7],
[8,9,10,11]
];

console.log(arr1);  

실행 결과

[
[0,1,2,3],
[4,5,6,7],
[8,9,10,11]
]

=================================================================================================================

> 크기가 N x M인 2차원 리스트(배열) 만들기

최신 JS (ES6 이상) 에서 사용가능한 문법
-> 한 줄로 2차원 배열을 초기화 할 수 있다.
-> 배열의 각 원소에 크기가 5인 배열을 할당한다 


(ex) let arr = Array.from(Array(4), () => new Array(5))

console.log(arr);

[
[<5 empty items>],
[<5 empty items>],
[<5 empty items>],
[<5 empty items>],
]

-> 다음과 같이 반복문을 이용하여 2차원 배열을 초기화 할 수 있다.

(ex)
// 반복문을 이용해 배열 초기화

let arr2 = new Array(3);
for(let i =0; i < arr2.length; i++ ){
arr2[i] = Array.from(
{ length : 4 },
(undefined,j) => i * 4 + j 
);
}
console.log(arr2);

실행 결과

[
[0,1,2,3],
[4,5,6,7],
[8,9,10,11]
]

===================================================================================================================

*** 
JS 배열은 동적 배열이다
배열이 생성된 이후에도 배열의 크기를 임의로 변경할 수 있다.
push() 메서드를 통해 배열의 가장 뒤쪽에 새로운 원소를 추가할 수 있다.

(ex)
let arr = [5,6,7,8,9];
arr.length = 8;
arr[7] = 3;
arr.push(1);

for(let x of arr){
console.log(x);
}


* concat() 메소드 : 여러 개의 배열을 이어 붙여서 합친 결과를 반환한다 O(N)
(ex)
let arr1 = [1,2,3,4,5];
let arr2 = [6,7,8,9,10];

let arr = arr1.concat(arr2,[11,12],[13]);

console.log(arr);

실행 결과

[
1,2,3,4,5,6,
7,8,9,10,11,12,13
]

* slice(left,right) 메소드 : 특정 구간의 원소를 꺼낸 배열을 반환한다 O(N)
(ex)
let arr = [1,2,3,4,5];
let result = arr.slice(2,4);

console.log(result);

실행 결과

[3,4]

* indexOf() 메소드 : 특정한 값을 가지는 원소의 첫째 인덱스를 반환한다 O(N)
- 만약, 해당하는 원소가 없는 경우 -1을 반환한다.

let arr = [7,3,5,6,6,2,1];

console.log(arr.indexOf(5));
console.log(arr.indexOf(6));
console.log(arr.indexOf(8));

실행 결과

2
3
-1



==========================================================================================================

*** 연결 리스트(Linked List)

- 연결 리스트는 각 노드가 한 줄로 연결되어 있는 자료 구조다.
- 각 노드는 (데이터,포인터)의 형태를 가진다.
- 포인터 : 다음 노드의 메모리 주소를 가리키는 목적으로 사용된다.

* 연결성 : 각 노드의 포인터는 다음 혹은 이전 노드를 가리킨다.


==> 연결 리스트를 이용하면, 다양한 자료 구조를 구현할 수 있다.
ex) 스택, 큐 등

JS는 연결 리스트를 활용하는 자료 구조를 제공한다.
그래서 연결 리스트를 실제로 구현해야 하는 경우는 적지만, 그 원리에 대해서 이해할 필요가 있음 

-

** 연결 리스트와 배열을 비교하여 장단점 파악이 중요

> 특정 위치의 데이터를 삭제할 때, 일반 배열에서는 O(N)만큼의 시간이 소요됨
--> 연결 리스트를 사용하면 연결만 끊어주면 됨
(따라서, 삭제할 위치를 정확히 알고 있다면 O(1)의 시간이 소요) 

>> 삽입시 : 배열 > 인덱스를 밀어서 삭제 후 삽입 / 삭제시에도 마찬가지 (최악의 경우 총 N만큼의 시간 요구 )
           연결 리스트 > 새 인덱스의 포인터가 다음 인덱스의 포인터를 가리킬 수 있도록 설계하는 경우 (1만큼의 시간 소요)












================================================================================================================
